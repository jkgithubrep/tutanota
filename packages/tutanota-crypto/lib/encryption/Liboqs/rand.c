#include <stdint.h>
#include <string.h>
#include <stdlib.h>

#define AMOUNT_OF_ENTROPY (64)
static uint8_t entropy[AMOUNT_OF_ENTROPY];
static size_t current_offset = sizeof(entropy);

#define REMAINING_ENTROPY (sizeof(entropy) - current_offset)

/**
 * Load random bytes. This function simply returns the remaining number of bytes to be filled if amount is 0.
 *
 * @param bytes  random bytes to be generated by the caller (NOTE: take care to clear this buffer afterward!)
 * @param amount number of bytes in the buffer
 * @return       remaining number of bytes in the entropy pool to be filled
 */
size_t TUTA_inject_entropy(uint8_t *bytes, size_t amount) {
	// Don't copy more than we need
	amount = amount > current_offset ? current_offset : amount;

	// Move the offset down
	current_offset -= amount;
	if (amount) {
		memcpy(entropy + current_offset, bytes, amount);
	}

	// Return remaining amount
	return current_offset;
}

/**
 * randombytes override - use external bytes
 */
void OQS_randombytes(uint8_t *random_array, size_t bytes_to_read) {
	if (bytes_to_read > REMAINING_ENTROPY) {
		exit(1);
	}

	uint8_t *entropy_to_copy = entropy + current_offset;

	memcpy(random_array, entropy_to_copy, bytes_to_read);
	memset(entropy_to_copy, 0, bytes_to_read); // clear out the bytes we just copied so it only exists in one place

	current_offset += bytes_to_read;
}

/**
 * exit override - lock up in an infinite loop instead (note that this is only called in case of a crash!)
 *                 this saves us from having to import things
 */
void exit(int reason) {
	while(1) {}
}